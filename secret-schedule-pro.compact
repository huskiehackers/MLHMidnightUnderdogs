pragma language_version >= 0.16 && <= 0.17;

import CompactStandardLibrary;

struct Time {
    year: Uint<16>;
    month: Uint<8>;
    day: Uint<8>;
    hour: Uint<8>;
    min: Uint<8>;
}

struct Meeting {
    meetingStart: Time;
    meetingEnd: Time;
}

module M {
    export ledger meetingTimes: Vector<128, Meeting>;

    // Get time and importance from website as tuples
    // [year, month, day, hour, min]
    witness getStartTime(): [Uint<16>, Uint<8>, Uint<8>, Uint<8>, Uint<8>];
    witness getEndTime(): [Uint<16>, Uint<8>, Uint<8>, Uint<8>, Uint<8>];
    witness getImportance(): Uint<8>;

    // Get info about user from db as Tuple
    // [tier, length, safetyTrained]
    witness getDB(): [Uint<8>, Uint<8>, Boolean];

    const startTime = getStartTime();
    const endTime = getEndTime();

    export circuit createMeeting(): Meeting {
        // Declare nested object (a meeting object with a meetingStart object and a meetingEnd object)
        return Meeting {meetingStart: Time {year: startTime[0], month: startTime[1], day: startTime[2], hour: startTime[3], min: startTime[4]}, meetingEnd: Time {year: endTime[0], month: endTime[1], day: endTime[2], hour: endTime[3], min: endTime[4]}};
    }

    // Calculate if user can book room
    export circuit userCredibility(importance: Uint<8>, tier: Uint<8>, length: Uint<8>, safety: Boolean): Boolean {
        const sum1: Uint<256> = (importance * 5) + (tier * 10) + (length * 5);
        const sum2: Uint<256> = safety ? sum1 + 30 : sum1;
        return sum2 > 60;
    }

    // Check if room is available
    export circuit roomAvail(): Boolean {
        const x = createMeeting();

        // Loop through all meetingTimes, if there is overlap, room is not available and return false
        for (const i of meetingTimes) {
            if ((x.meetingStart >= i.meetingStart || x.meetingEnd >= i.meetingStart)
                && (x.meetingStart <= i.meetingEnd || x.meetingEnd <= i.meetingEnd)) {
                    return false;
                }
        }

        // If pass loop, return true
        return true;
    }
}